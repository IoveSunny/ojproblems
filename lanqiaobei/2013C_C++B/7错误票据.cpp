/*标题：错误票据
  3 
  4     某涉密单位下发了某种票据，并要在年终全部收回。
  5 
  6     每张票据有唯一的ID号。全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。
  7 
  8     因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。
  9 
 10     你的任务是通过编程，找出断号的ID和重号的ID。
 11 
 12     假设断号不可能发生在最大和最小号。
 13 
 14 要求程序首先输入一个整数N(N<100)表示后面数据行数。
 15 接着读入N行数据。
 16 每行数据长度不等，是用空格分开的若干个（不大于100个）正整数（不大于100000）
 17 每个整数代表一个ID号。
 18 
 19 要求程序输出1行，含两个整数m n，用空格分隔。
 20 其中，m表示断号ID，n表示重号ID
 21 
 22 例如：
 23 用户输入：
 24 2
 25 5 6 8 11 9
 26 10 12 9
 27 
 28 则程序输出：
 29 7 9
 30 
 31 
 32 再例如：
 33 用户输入：
 34 6
 35 164 178 108 109 180 155 141 159 104 182 179 118 137 184 115 124 125 129 168 196
 36 172 189 127 107 112 192 103 131 133 169 158
 37 128 102 110 148 139 157 140 195 197
 38 185 152 135 106 123 173 122 136 174 191 145 116 151 143 175 120 161 134 162 190
39 149 138 142 146 199 126 165 156 153 193 144 166 170 121 171 132 101 194 187 188
 40 113 130 176 154 177 120 117 150 114 183 186 181 100 163 160 167 147 198 111 119
 41 
 42 则程序输出：
 43 105 120
 44 
 45 
 46 资源约定：
 47 峰值内存消耗 < 64M
 48 CPU消耗  < 1000ms
 49 
 50 
 51 请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。
 52 
 53 所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。
 54 
 55 注意: main函数需要返回0
 56 注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。
 57 注意: 所有依赖的函数必须明确地在源文件中 #include <xxx>， 不能通过工程设置而省略常用头文件。
 58 
 59 提交时，注意选择所期望的编译器类型。
 *
 * （首先处理好字符串问题（读取与存放），用到了atoi(string) -->#include <cstdlib>）
 * 解题方法：1、标记数组（可顺带找出重复的值）
 * 			2、确定标记范围
 * 			3、遍历一边标记数组，找出未标记（即断号）
 * 
 *  其他方法：排序;
 * 			再找相等--》重号;
 * 			找不相等且不连续--》断号;
 * 	(可用stl.list双向链表存放，节省空间)
 * 
 * */

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>

int vis[10000];

using namespace std;

int main(void) {
	char c;
	int i, n;
	int max=0, min=100000;
	char temp[7];
	// mID断号, nID重号
	int mID=-1, nID=-1;

	scanf("%d", &n);
	getchar();

	memset(vis, 0, sizeof(vis));
	while(n--) {
		i = 0;
		c = '0';
		while(c !='\n') {
			// 防止最开始的空格
			while((c=getchar())==' ')
				;
			// 此时 c != ' '
			while(c != ' ' && c != '\n') {
				temp[i++] = c;
				c = getchar();
			}
			temp[i] = '\0';
			i = 0;

			// 
			int t = atoi(temp);
			//
			// 防止换行符造成0
			if(t==0 && c=='\n')
				break;

			// 标记数组，顺带找出重复的值
			if(vis[t] == 1)
				nID = t;
			else
				vis[t] = 1;

			// 找出范围
			if(max<t)
				max = t;
			if(min>t)
				min = t;
		}
		// printf("\n");
	}

	// printf("%d %d\n", max, min);
	for(i=min; i<=max; i++) {
		if(vis[i] == 0) {
			mID = i;
			break;
		}
	}
	printf("%d %d\n", mID, nID);

	return 0;
}
